/*

    Copyright Â© 2016-2017 Dominique Climent, Florian Dubath

    This file is part of Monnaie-Leman Wallet.

    Monnaie-Leman Wallet is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Monnaie-Leman Wallet is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Monnaie-Leman Wallet.  If not, see <http://www.gnu.org/licenses/>.

*/
"use strict";

var arrays  = require("../utils/arrays"),
    visitor = require("./visitor");

/* AST utilities. */
var asts = {
  findRule: function(ast, name) {
    return arrays.find(ast.rules, function(r) { return r.name === name; });
  },

  indexOfRule: function(ast, name) {
    return arrays.indexOf(ast.rules, function(r) { return r.name === name; });
  },

  alwaysAdvancesOnSuccess: function(ast, node) {
    function advancesTrue()  { return true;  }
    function advancesFalse() { return false; }

    function advancesExpression(node) {
      return advances(node.expression);
    }

    var advances = visitor.build({
      rule:  advancesExpression,
      named: advancesExpression,

      choice: function(node) {
        return arrays.every(node.alternatives, advances);
      },

      action: advancesExpression,

      sequence: function(node) {
        return arrays.some(node.elements, advances);
      },

      labeled:      advancesExpression,
      text:         advancesExpression,
      simple_and:   advancesFalse,
      simple_not:   advancesFalse,
      optional:     advancesFalse,
      zero_or_more: advancesFalse,
      one_or_more:  advancesExpression,
      semantic_and: advancesFalse,
      semantic_not: advancesFalse,

      rule_ref: function(node) {
        return advances(asts.findRule(ast, node.name));
      },

      literal: function(node) {
        return node.value !== "";
      },

      "class": advancesTrue,
      any:     advancesTrue
    });

    return advances(node);
  }
};

module.exports = asts;
